# 解决方法

## 方法一
题目给定的时间复杂度在O(N^2)以内，空间复杂度为O(1)。
因此可以使用原位Sort的方法，排序后扫描数组一遍就可以找到重复的数了。
这个方法的时间复杂度是O(NlogN)，空间复杂度是O(1)。


## 方法二
使用Bit manipulation。
若是32位的机器，我们单独来看每一位。如果这一位上的数的Bit加和比1-n的Bit加和大，那么说明最终的
结果上这一位上有数，最终合成得到的数就是Dup的数字


## Best
Best的方法非常巧妙的将这个问题转化成了一个图的表达方式：当数组的范围限定在1-n的时候，可以想象
其实每个数组的元素都连接到了另一个元素（或者是自己）上，也就是一个有向图的表达形式。

那么当这个数组中存在一个Dup的时候，图中则必须存在一个环，那么本题的任务就转换成了寻找环的起点。
(并不考虑数组中i元素处在index i时所形成的和自身连接的环)

寻找环的起点的方法就是用快慢指针：

1. 快指针每次走两步，慢指针走一步
2. 两者相遇的时候，将快指针重置回起点
3. 快指针和慢指针每次各移动一步
4. 两者再次相遇的时候就是环的入口

这是因为假设第一次相遇的时候慢指针走了n，快指针则走了2n，比慢指针多走了n步。
那么拆解一下，快指针比慢指针多走的n是“环的剩余长度 + 慢指针进入环的距离”，慢指针总计走的n是
“起点到环入口的距离 + 慢指针进入环的距离”，也就是说起点到入口的距离在此时正好等于慢指针绕回到
起点的距离。

# C++知识

Bit Manipulation

[variable]<<[number of places]  将variable左移n位，相当于乘以2^n
[variable]<<[number of places]  将variable右移n位，相当于除以2^n

& 按位与
| 按位或
^ 按位异或
~ 按位非

注意虽然说是Bit manipulation，实际上我们操作的最小单位仍然是8 bit的byte。
参考这篇[教程](http://www.cprogramming.com/tutorial/bitwise_operators.html)